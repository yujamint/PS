# 다익스트라 알고리즘

## 문제
```
[설명]
아래의 가중치 방향그래프에서 1번 정점에서 모든 정점으로의 최소 거리비용을 출력하는 프로
그램을 작성하세요. (경로가 없으면 Impossible를 출력한다)
```
![image](https://velog.velcdn.com/images/db_jam/post/cf8e15f3-2cf1-45f0-8649-a329fcc3fcdc/image.png)
```
[입력]
첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연
결정보와 거리비용이 주어진다.


[출력]
1번 정점에서 각 정점으로 가는 최소비용을 2번 정점부터 차례대로 출력하세요.
```
```
입력예제 1
6 9
1 2 12 // 1번 정점에서 2번정점으로 가는데 12의 비용이 든다.
1 3 4
2 1 2
2 3 5
2 5 5
3 4 5
4 2 2
4 5 5
6 4 5

출력예제 1
2 : 11
3 : 4
4 : 9
5 : 14
6 : impossible
```
다익스트라 알고리즘 전제조건 : 간선의 가중치 값이 음수가 나오면 안 된다.

정점 개수 n일 때,
1차원 배열 dis 생성(1~n), 모든 인덱스 Integer.MAX_VALUE 값으로 초기화
- 1번 정점에서 i번 정점까지 가는 최소 거리
- dis[1] = 0 (1번 정점에서 1번 정점까지 가는 거리)
- 더 작은 값을 찾을 때마다 갱신
    - 1 -> 2 = 12이고, 이는 기존의 Integer.MAX_VALUE보다 작은 값이므로 dis[2] = 12로 대체한다.
    - 1 -> 3 = 4이고, 이는 기존의 Integer.MAX_VALUE보다 작은 값이므로 dis[3] = 4로 대체한다.
- 1번 정점에서 갈 수 있는 점은 다 뻗어나갔기 때문에 그 다음 1에서부터 갈 때 최소비용을 갖는 정점을 dis 배열에서 찾는다.
- dis 배열에서 dis[1]과 초기값이 아닌 값 중에 최소값에서 뻗어나간다.
_ dis[1]을 제외한 최소값은 dis[3]이므로 3번 정점에서 뻗어나간다.
    - 2번 정점을 거치는 순간 dis[3]보다 커지기 때문에 최소값인 dis[3]에서부터 뻗어나간다.(dis 배열의 최소값은 dis[3]으로 확정된 것임)
    - 3번 정점에서는 4번 정점을 갈 수 있다.
    - 3 -> 4 = 5이고, dis[3] + 5 = 4 + 5 = 9 (1 -> 3 -> 4)
        - 원래의 dis[4] = Integer.MAX_VALUE 보다 작은 값이므로 9로 대체한다.(최소 거리 찾는 문제!)
- 3번 정점에서 갈 수 있는 점은 다 뻗어나갔기 때문에 그 다음 최소값을 찾는다.
- dis[3]을 제외한 최소값은 dis[4]이므로 4번 정점에서 뻗어나간다.
    - 4번 정점에선 2번 정점과 5번 정점 갈 수 있다.(입력예제)
    - 4 -> 2 = 2이고, dis[4] + 2 = 9 + 2 = 11 (1 -> 3 -> 4 -> 2)
      - 이는 원래의 dis[2] = 12 보다 작으므로 11로 대체된다. 
    - 4 -> 5 = 5이고, dis[4] + 5 = 9 + 5 = 14 (1 -> 3 -> 4 -> 5)
        - 이는 원래의 dis[5] = Integer.MAX_VALUE보다 작으므로 14로 대체된다.
- 4번 정점에서 갈 수 있는 점은 다 뻗어나갔기 때문에 그 다음 최소값을 찾는다.
- dis[3], dis[4]를 제외한 최소값은 dis[2]이므로 2번 정점에서 뻗어나간다.
    - 2번 정점에선 1번,3번,5번 정점을 갈 수 있다.
    - 2 -> 1 = 2이고, dis[2] + 2 = 13 (1 -> 3 -> 4 -> 2 -> 1)
        - 원래의 dis[1] = 0 보다 크기 때문에 대체하지 않는다.
        - 사실 시작점이라 당연히 안 된다.
    - 2 -> 3 = 5이고, dis[2] + 5 = 16 (1 -> 3 -> 4 -> 2 -> 3)
        - 원래의 dis[3] = 4 보다 크기 때문에 대체하지 않는다.
        - 3번 정점을 지났다가 다시 가는 것이므로 더 클 수 밖에 없다.
    - 2 -> 5 = 5이고, dis[2] + 5 = 16 (1 -> 3 -> 4 -> 2 -> 5)
        - 원래의 dis[5] = 14 보다 크기 때문에 대체하지 않는다.
- 2번 정점에서 갈 수 있는 점은 다 뻗어나갔기 때문에 그 다음 최소값을 찾는다.
- dis[2], dis[3], dis[4]를 제외한 최소값은 dis[5]이므로 5번 정점에서 뻗어나간다.
    - 5번 정점에서 갈 수 있는 점은 존재하지 않는다.
- 6번 정점에 갈 수 있는 점은 존재하지 않기 때문에 최소거리를 모두 찾았다.

위의 경우 dis 배열에서 간선의 최소 비용을 찾을 때 dis 배열의 모든 값을 돌면서 최소값을 찾는 **선형 탐색**으로 찾기 때문에 시간복잡도가 O(n^2)이다.
이때, **PriorityQueue를 사용하면 최소 비용을 log(n)번**만에 찾을 수 있기 때문에 시간복잡도가 O(nlog(n))으로 줄어든다.
 - pQ가 이진트리로 구성돼있기 때문이다.

구현
- 정점과 비용을 속성으로 갖는 Edge 클래스를 생성한다.
  - 최소비용인 정점에서 먼저 뻗어나가기 위해 비용을 기준으로 오름차순 정렬한다.
- Edge 객체를 저장하는 ArrayList를 저장하는 ArrayList를 생성한다.(2중 ArrayList)
- Edge 객체를 저장하는 pQ를 생성하고 pQ에 1,0을 넣으면서 시작한다.
- pQ에서 간선을 poll하고, 해당 간선이 향하는 정점(now)과 연결된 간선들을 ArrayList를 통해 접근한다.
    - poll한 간선이 향하는 정점까지의 cost(nowCost)가 기존의 cost(dis[now])보다 크다면 어떻게 뻗어나가도 더 큰 값이 나올 수 밖에 없으므로 더 이상 실행하지 않는다.
    - 만약, now와 연결된 간선으로 가는 것이 기존의 cost보다 작다면 대체하고, pQ에 넣는다.(뻗어나가기 위해)
        - 1 -> 2 = 12일 때, dis[2](기존의 cost)와 dis[1] + 12를 비교하는 것이다.
- now와 연결돼있고, 조건을 만족하는 간선을 모두 pQ에 넣었다면, 다음 최소값을 찾아 뻗어나간다.
    - **이때, pQ에서 poll을 하면서 바로 비용이 최소값인 정점을 뽑게 된다.(선형 탐색과의 차이점!)**
- pQ에서 꺼낸 정점에서 뻗어나가며 위 과정을 반복한다.

1. 최소비용인 간선을 pQ에서 뽑고, 그 간선이 향하는 정점(now)로 이동한다.
2. 이동한 정점(now)과 연결된 간선을 ArrayList에서 가져온다. (graph.get(now) -> now와 연결된 간선 list)
3. 해당 간선(vtx, cost)이 조건을 만족하는지 확인한다.
    - 조건 : 정점 1에서부터 now를 거쳐 vtx까지 가는 비용이 원래의 비용(dis[vtx]보다 작다.
4. 만족한다면 해당 간선을 pQ에 넣는다.
5. 2~4번 과정을 모두 반복하며 now와 연결된 간선을 모두 처리했다면, 1번 과정으로 돌아가서 반복한다.
    

**얻어갈 것**
- 다익스트라 알고리즘
    - 복습 및 블로깅 필수