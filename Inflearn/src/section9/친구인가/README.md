# 친구인가? (Disjoint-set : Union & Find)

## 문제

```
[설명]
오늘은 새 학기 새로운 반에서 처음 시작하는 날이다. 현수네 반 학생은 N명이다. 현수는 각 학생들의 친구관계를 알고 싶다.

모든 학생은 1부터 N까지 번호가 부여되어 있고, 현수에게는 각각 두 명의 학생은 친구 관계가 번호로 표현된 숫자쌍이 주어진다.

만약 (1, 2), (2, 3), (3, 4)의 숫자쌍이 주어지면 1번 학생과 2번 학생이 친구이고, 2번 학생과 3번 학생이 친구, 3번 학생과 4번 학생이 친구이다.

그리고 1번 학생과 4번 학생은 2번과 3번을 통해서 친구관계가 된다.

학생의 친구관계를 나타내는 숫자쌍이 주어지면 특정 두 명이 친구인지를 판별하는 프로그램을 작성하세요.

두 학생이 친구이면 “YES"이고, 아니면 ”NO"를 출력한다.


[입력]
첫 번째 줄에 반 학생수인 자연수 N(1<=N<=1,000)과 숫자쌍의 개수인 M(1<=M<=3,000)이 주어지고,

다음 M개의 줄에 걸쳐 숫자쌍이 주어진다.

마지막 줄에는 두 학생이 친구인지 확인하는 숫자쌍이 주어진다.


[출력]
첫 번째 줄에 “YES"또는 "NO"를 출력한다.
```
```
예시 입력 1 
9 7
1 2
2 3
3 4
1 5
6 7
7 8
8 9
3 8

예시 출력 1
NO
```

>서로소 집합 : 공통 원소가 없는 두 집합
> 
> ex) {1,2,3}과 {4,5,6}은 서로소이며 {1,2,3}과 {3,4,5}는 아니다.

이 문제는 마지막 줄에 입력받은 두 친구가 속해있는 집합이 서로소 집합인지 확인하는 문제이다.

- 1번~n번 친구가 각각 속해있는 집합을 저장하는 unf 배열을 생성한다.
  - m개의 친구 관계를 입력을 받기 전에 unf[i] = i로 초기화한다.(관계를 입력받지 않았으니 같이 속해있는 집합이 없는 것)
- 한 친구의 번호(v)를 파라미터로 주면 그 친구가 속해있는 집합을 찾는 Find 함수를 구현한다.
  - v == unf[v]일 때, unf[v]를 그대로 return 
  - v != unf[v]일 때, unf[v]에 Find(unf[v]) 할당한 후 return
- 두 친구의 번호(a,b)를 각각 파라미터로 받아 친구관계를 맺는(같은 집합에 속하도록 하는) Union 함수를 구현한다.
  - a가 속한 집합인 fa = Find(a), b가 속한 집합인 fb = Find(b)를 각각 구한다.
  - a와 b가 같은 집합에 속해있지 않다면(fa != fb) unf[fa] = fb;
- 입력받은 모든 친구관계에 대해 Union 함수를 실행했다면, 마지막으로 입력받은 두 친구(a,b)가 속해있는 집합이 같은지 확인한다.
  - Find(a) == Find(b) 라면, 같은 집합에 속해있으므로 친구관계이다.
  - Find(a) == Find(b) 라면, 서로소 집합이다.

실행 
- unf[i] = i 로 초기화돼있는 상태
- Union(1,2)
  - fa = find(1) = 1, fb = find(2) = 2
  - unf[fa] = fb -> unf[1] = 2;
  - unf = {**2, 2**, 3, 4, 5, 6, 7, 8, 9}
- Union(2,3)
  - fa = find(2) = 2, fb = find(3) = 3
  - unf[fa] = fb -> unf[2] = 3;
  - unf = {2, **3, 3**, 4, 5, 6, 7, 8, 9}
- Union(3,4)
  - fa = find(3) = 3, fb = find(4) = 4
  - unf[fa] = fb -> unf[3] = 4;
  - unf = {2, 3, **4, 4**, 5, 6, 7, 8, 9}
- Union(1,5)
  - fa = find(1) // 1 != unf[1] --> unf[1] = find(2)
    - find(2) // 2 != unf[2] --> unf[2] = find(3)
      - find(3) // 3 != unf[3] --> unf[3] = find(4)
        - find(4) // 4 == unf[4] --> return 4
      - find(3) return unf[3] = return 4
    - find(2) return unf[2] = return 4
  - **fa = find(1) return unf[1] = return 4**
  - 즉, find(1) = unf[1] -> find(2) = unf[2] -> find(3) = unf[3] -> find[4] = 4
  - find(1)만 진행했을 때의 unf = {**4, 4, 4, 4**, 5, 6, 7, 8, 9}
  - fb = **find(5) = 5**
  - unf[fa] = fb -> unf[4] = 5;
  - unf = {4, 4, 4, **5, 5**, 6, 7, 8, 9}
- Union(6,7)
  - fa = find(6) = 6, fb = find(7) = 7
  - unf[fa] = fb -> unf[6] = 7;
  - unf = {4, 4, 4, 5, 5, **7, 7**, 8, 9}
- Union(7,8)
  - fa = find(7) = 7, fb = find(8) = 8
  - unf[fa] = fb -> unf[7] = 8;
  - unf = {4, 4, 4, 5, 5, 7, **8, 8**, 9}
- Union(8,9)
  - fa = find(8) = 8, fb = find(9) = 9
  - unf[fa] = fb -> unf[8] = 9;
  - unf = {4, 4, 4, 5, 5, 7, 8, **9, 9**}

** 얻어갈 것**
- 서로소 집합은 Find, Union 함수 구현!
- Union&Find는 외워놓자