# 경로 탐색(인접행렬)

## 문제

```
방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프
로그램을 작성하세요. 아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는
1 2 3 4 5
1 2 5
1 3 4 2 5
1 3 4 5
1 4 2 5
1 4 5
총 6 가지입니다.
```
![image](https://velog.velcdn.com/images%2Fjhjcoding%2Fpost%2F7ee99986-52e7-4acc-a900-476ae9d5be30%2Fimage.png)
```
[입력]
첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연
결정보가 주어진다.

[출력]
총 가지수를 출력한다.
```
```
입력예제 1
5 9
1 2
1 3
1 4
2 1
2 3
2 5
3 4
4 2
4 5

출력예제 1
6
```

그래프에서의 경로
- 한 번 방문한 곳은 다시 방문하지 않는다.

**풀이방법**
- 한 정점에서 다르 정점으로 이동할 수 있는지 확인하기 위해 입력받은 간선을 인접행렬로 표현한다.
- 그래프에서의 경로를 따질 때, 한 번 방문한 곳은 다시 방문하지 않기 때문에 이를 체크하기 위해 ch 배열을 만든다.
- 1에서부터 N까지의 경로를 찾는 문제이기 때문에, DFS 함수의 파라미터를 1로 주면서 시작한다.
- for문을 돌면서 (1)1에서 갈 수 있는 정점인지, (2)이 정점을 이미 지나오진 않았는지, 즉 ch 배열에 해당 인덱스의 값이 0인지를 확인한다.
    - 2가지 조건을 모두 만족하는 정점 A라면, 그 점을 지날 것이기 때문에 ch 배열의 A 인덱스를 1로 체크해놓고 A를 파라미터로 주는 DFS 함수를 호출한다.(재귀호출)
    - A정점을 파라미터로 주며 DFS 함수를 시작함으로써, 위 과정을 반복한다.
    - 재귀호출을 반복하며 N 정점에 도착하게 되면, 1부터 N까지의 경로를 확인한 것이므로 answer++;
    
실행 예시
1. DFS(1) 실행 - for문을 돌며 1번 정점에서 갈 수 있는 점 확인
    - i = 1일 때, 1은 이미 지나온 정점 -> ch[1] = 1이므로 X
    - i = 2일 때, graph[1][2] = 1이므로 지날 수 있고 , ch[2] = 0이므로 ch[2] = 1 할당 후 DFS(2) 호출
    - DFS(2) 실행 - for문을 돌며 2번 정점에서 갈 수 있는 점 확인(현재 경로 : 1 - 2)
        - i = 1일 때, 1은 이미 지나온 정점 -> ch[1] = 1이므로 X
        - i = 2일 때, ch[2] = 2이므로X
        - i = 3일 때, graph[2][3] = 1이므로 지날 수 있고, ch[3] = 0이므로 , ch[3] = 1 할당 후 DFS(3) 호출
        - DFS(3) 실행 - for문을 돌며 3번 정점에서 갈 수 있는 점 확인(현재 경로 : 1 - 2- 3)
            - i = 1,2,3일 때, 이미 지나온 점 -> ch[i] = 1이므로 X
            - i = 4일 때, graph[3][4] = 1이므로 지날 수 있고, ch[4] = 0이므로  ch[4] = 1 할당 후 DFS(4) 호출
            - DFS(4) 실행 - 4번 정점에서 갈 수 있는 점 확인(현재 경로 : 1 - 2 - 3 - 4)
                - i = 1,2,3,4일 때, 이미 지나온 점 -> ch[i] = 1이므로 X
                - i = 5일 때, graph[4][5] = 1이므로 지날 수 있고, ch[5] = 0이므로  ch[5] = 1 할당 후 DFS(5) 호출
                - DFS(5) 실행 - 5 == n 이므로 answer++ , DFS(5) 종료
            - ch[4] = 0으로 4번 정점 체크 풀면서 DFS(4) 종료
        - ch[3] = 0으로 3번 정점 체크 풀면서 DFS(3) 종료
    - ch[2] = 0으로 2번 정점 체크 풀면서 DFS(2) 종료
    - i = 3일 때, graph[1][3] = 1이므로 지날 수 있고, ch[3] = 0이므로 ch[3] = 1 할당 후 DFS(3) 호출
    - DFS(3) 실행 - for문 돌며 3번 정점에서 갈 수 있는 점 확인
        - i = 1,3일 때, 이미 지나온 점 -> ch[i] = 1이므로 X
        - i = 2일 때, graph[3][2] = 0 이므로 지날 수 없음
        - i = 4일 때, graph[3][4] = 1이므로 지날 수 있고, ch[4] = 0이므로 ch[4] = 1 할당 후, DFS(4) 호출
        - DFS(4) 실행 - 4번 정점에서 갈 수 있는 점 확인
            - i = 1,3,4일 때, 이미 지나온 점이므로 X
            - i = 2일 때, graph[4][2] =1, ch[2] = 0이므로 DFS(2) 호출
            - DFS(2) 실행..... ~

**얻어갈 것**
- DFS
- 백트래킹