# 그래프 최단거리(BFS)

## 문제
```
[설명]
다음 그래프에서 1번 정점에서 각 정점으로 가는 최소 이동 간선수를 출력하세요.
1 2 5
3 4 6
```
![image](https://velog.velcdn.com/images%2Fjhjcoding%2Fpost%2F76b38e80-0440-45da-b46e-d59605cd70ac%2Fimage.png)
```
[입력]
첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연
결정보가 주어진다.


[출력]
1번 정점에서 각 정점으로 가는 최소 간선수를 2번 정점부터 차례대로 출력하세요.
```
```
입력예제 1
6 9
1 3
1 4
2 1
2 5
3 4
4 5
4 6
6 2
6 5

출력예제 1
2 : 3
3 : 1
4 : 1
5 : 2
6 : 2
```

**풀이방법**
- 인접리스트를 사용해서 거리를 표현한다.
- Integer 형 ArrayList를 담는 ArrayList를 생성하고, 각 정점마다 갈 수 있는 점들을 담는다.
- 이미 지나온 점인지를 확인하기 위한 ch 배열과 거리를 기록하기 위한 dis 배열을 생성한다.
    - 시작하는 정점인 1은 항상 지나기 때문에 ch[1] = 1, 시작지점이기 때문에 dis[1] = 0으로 설정한다.
    - 시작점인 1을 기준으로 나머지 점들까지의 거리 또한 정해진다.
- 최단거리를 구하는 문제이기 때문에 Queue를 생성하고, 시작지점인 1을 넣는다.
- 그 후 다음 과정을 반복한다.
    - Queue에서 정점 cv를 poll한다.
    - 인접리스트를 통해 cv에서 갈 수 있는 모든 점 중에 아직 지나지 않은 점 nv(ch[nv] == 0)를 모두 큐에 넣는다.
        - 큐에 넣을 때, 해당 점을 지날 것이기 때문에 ch[cv] = 1로 체크한다.
        - 거리는 1부터 cv까지의 최단거리에서 한 칸 더 이동한 것이므로 dis[nv] = dis[cv] + 1이다.
- 과정을 모두 반복하면 1에서 모든 정점까지의 최단거리가 dis 배열에 할당돼있다.