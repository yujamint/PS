# 동전교환

## 문제
```
[설명]
다음과 같이 여러 단위의 동전들이 주어져 있을때 거스름돈을 가장 적은 수의 동전으로 교환해주려면 어떻게 주면 되는가?

각 단위의 동전은 무한정 쓸 수 있다.


[입력]
첫 번째 줄에는 동전의 종류개수 N(1<=N<=12)이 주어진다. 두 번째 줄에는 N개의 동전의 종류가 주어지고,

그 다음줄에 거슬러 줄 금액 M(1<=M<=500)이 주어진다.각 동전의 종류는 100원을 넘지 않는다.


[출력]
첫 번째 줄에 거슬러 줄 동전의 최소개수를 출력한다.
```
```
예시 입력 1 
3
1 2 5
15

예시 출력 1
3

힌트
출력 설명 : 5 5 5 동전 3개로 거슬러 줄 수 있다.
```
**첫 번째 풀이방법**
- 동전 개수를 가장 적게 사용하면서 15원을 만드는 문제이다.
- 나는 이 문제를 보고 스카이콩콩을 타고 1,2,5 칸씩 앞으로 이동할 수 있을 때, 가장 적은 횟수의 이동으로 15칸을 이동하는 방법, 즉 최단거리를 구하는 문제라고 생각했다.
- 그렇기 때문에, BFS로 접근했다.
- 큐에 선택한 동전의 총합 금액을 offer 한다.
    - 처음(0레벨)에는 동전이 선택되지 않은 상태기 때문에 0
- 큐에서 poll을 하고, 해당 금액이 m인지 확인한다. m이라면 그 시점의 레벨을 리턴한다.
    - 레벨은 고른 동전의 개수를 의미하고, BFS이기 때문에 이때의 레벨이 최소로 사용하는 동전 개수이다.
- poll한 금액이 m이 아니라면, 동전 종류를(1, 2, 5) 각각 더한 금액을 offer 한다.
  - 이때, 시간복잡도를 줄이기 위해 동전을 더한 금액이 m보다 크거나, 이미 나왔던 값이라면 offer하지 않는다.
- 바로 위 단계에서 offer한 금액을 poll하며 해당 금액이 m인지 확인하며 위 과정을 반복한다.

최단거리를 구하는 문제이기 때문에 BFS를 선택했고, DFS보다 더 효율적이라고 생각한다. 강의에서는 DFS를 선택해서 문제를 풀었지만, 그저 DFS를 사용해서 문제 푸는 법을 보여주기 위한 건지, DFS가 더 효율적이라고 선택한 것인지는 잘 모르겠다.*

Code
```java
import java.util.LinkedList;
import java.util.Queue;

public void BFS(int t){
    Queue<Integer> Q = new LinkedList<>();
    Q.offer(t);
    int L = 0;
    while(!Q.isEmpty()){
        int len = Q.size();
        for(int i=0; i<len; i++){
            int pt = Q.poll();
            if(pt == m) {
                answer = L;
                return;
            }
            for(int j=0; j<n; j++){
                int nt = tokens[j];
                if(pt+nt <= m)
                    Q.offer(pt+nt);
            }
        }
        L++;
    }
}
```

**강의 풀이방법**
- 중복순열 문제를 풀 때와 같이, 레벨마다 n개의 동전 중에서 어떤 동전을 넣을지 고르는 문제이기 때문에 for문에서 동전을 고르고 재귀호출을 한다.
- 선택해야 되는 원소의 개수가 정해져 있는 것이 아니라 종료 조건은 금액이 m으로 맞춰졌을 때이다.
- 최소 횟수를 찾아서 바로 종료하는 BFS와 다르게, 모든 케이스를 확인하고 그 중에서 최선의 케이스로 선택하는 DFS이기 때문에 answer를 최소값으로 갱신한다.
- 시간복잡도를 줄이기 위해서 다음 두 가지 방법을 사용할 수 있다.
    1. 입력받은 배열을 내림차순으로 정렬함으로써 금액이 큰 동전으로 목표 금액을 채워나간다.
    2. answer는 최소값을 갱신하기 때문에, answer 이상의 레벨에서는 실행을 하지 않는다.
        - answer 이상의 레벨에서 문제 조건을 만족한다고 해도, 최소값을 구하는 문제이기 때문에 더 이상 실행할 필요가 없기 때문이다.
    - 이 두 가지 방법을 사용하면, 금액이 큰 동전을 먼저 사용함으로써 최소 동전 개수를 가장 먼저 구하게 되고 그 값을 기준으로 불필요한 단계는 생략할 수 있다.
    
** 얻어갈 것**
- 시간복잡도를 줄이는 방법
    - 큰 동전으로 먼저 채워나가기
    - 최소값을 구할 때, 최소값 이후의 단계는 생략하기.