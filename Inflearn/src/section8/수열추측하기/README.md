# 수열 추측하기

## 문제
```
[설명]
가장 윗줄에 1부터 N까지의 숫자가 한 개씩 적혀 있다. 그리고 둘째 줄부터 차례대로 파스칼의 삼각형처럼 위의 두개를 더한 값이 저장되게 된다.

예를 들어 N이 4 이고 가장 윗 줄에 3 1 2 4 가 있다고 했을 때, 다음과 같은 삼각형이 그려진다.
```
![Image](https://cote.inflearn.com/public/upload/e2f3cae26a.jpg)
```
N과 가장 밑에 있는 숫자가 주어져 있을 때 가장 윗줄에 있는 숫자를 구하는 프로그램을 작성하시오.

단, 답이 여러가지가 나오는 경우에는 사전순으로 가장 앞에 오는 것을 출력하여야 한다.


[입력]
첫째 줄에 두개의 정수 N(1≤N≤10)과 F가 주어진다.

N은 가장 윗줄에 있는 숫자의 개수를 의미하며 F는 가장 밑에 줄에 있는 수로 1,000,000 이하이다.


[출력]
첫째 줄에 삼각형에서 가장 위에 들어갈 N개의 숫자를 빈 칸을 사이에 두고 출력한다.

답이 존재하지 않는 경우는 입력으로 주어지지 않는다.
```
```
예시 입력 1 
4 16

예시 출력 1
3 1 2 4
```

파스칼의 삼각형 원리
- 1부터 4까지의 수열이 a b c d라고 가정하자.
- 가장 밑에 줄에 있는 수 f는 다음과 같다.
    - a + 3b + 3c + d
    - ex) 3 1 2 4 일 때, 3 + 1\*3 + 2\*3 + 4 = 16
- 이는 n개의 수열이 있고 수열의 각 숫자의 인덱스가 r이라고 했을 때, 각 숫자에 (n-1)Cr을 곱한 값과 같다.

이러한 원리를 이용하여 접근한다.

**첫 번째 풀이방법**
- 파스칼의 삼각형 가장 아래 값을 구하기 위해서는 n-1의 조합 값을 구해놔야 하기 때문에 Combibnation 함수를 구현하고, cn 배열에 저장한다.
- 순열을 구하기 위해 다음 과정을 반복한다.
    - 레벨마다, n개의 숫자 중에서 어떤 수를 수열에 넣을지 for문을 통해 결정한다.
        - 수열에서 같은 숫자가 중복되면 안 되기 때문에 ch배열을 통해 이미 수열에 들어간 숫자인지 체크한다.
    - 수열에 넣을 숫자를 결정한 뒤에는 재귀호출을 통해 다음 레벨로 넘어간다.
- 레벨(L) == n이 되면 모든 숫자를 결정한 것이므로 수열(pm)이 완성된 것이다.
- 완성된 수열(pm)과 구해놨던 n-1의 조합의 값(cn)을 인덱스에 맞게 곱해주면서 총 합(sum)을 구한다.
- 총합이 입력받은 f와 같다면 문제조건을 만족하므로 해당 수열을 출력하고 함수를 끝낸다.
    - 여기서 그냥 return을 하게 된다면 문제 조건을 만족하는 수열을 만들어낸 함수만 종료되고, stack에 여전히 쌓여있는 함수들은 그대로 실행된다.
        - ex) (3 1 2 4)가 문제 조건을 만족했다면, 그 뒤의 함수는 실행을 하지 않아야 되는데 return을 하면 (3 1 2 4)를 만들어낸 함수만 종료되고, stack에 쌓여있던 다음 함수들(3 2 1 4)이 호출된다.
    - 이를 막기 위해서 조건 변수인 flag를 만들고, 함수 최상단에 flag=true일 때, 함수가 종료되도록 하는 코드를 작성하고, 그 뒤의 함수도 바로 종료될 수 있도록 한다.

Code
```java
package section8.수열추측하기;

import java.util.Scanner;

public class Main {
    static int n,f, sum;
    static int[] ch, arr, pm, cn;
    static int[][] mem = new int[11][11];
    static boolean flag = false;

    public int Combination(int n, int r){
        if(mem[n][r] > 0) return mem[n][r];
        if(r==0 || r==n) return 1;
        return mem[n][r] = Combination(n-1, r-1) + Combination(n-1,r);
    }
    public void DFS(int L){
        if(flag) return;
        sum = 0;
        if(L==n) {
            for(int i=0; i<n; i++){
                sum += cn[i] * pm[i];
            }
            if(sum == f){
                for(int x : pm) System.out.print(x + " ");
                flag = true;
            }
        }
        else {
            for(int i=0; i<n; i++){
                if(ch[i]==0){
                    ch[i] = 1;
                    pm[L] = arr[i];
                    DFS(L+1);
                    ch[i] = 0;
                }
            }
        }
    }
    public static void main(String[] args) {
        Main T = new Main();
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        f = sc.nextInt();
        ch = new int[n]; // 순열 만들 때 중복 체크 1~n
        pm = new int[n]; // 순열 1~n
        cn = new int[n]; // (n-1)Cr 값 들어있는 배열 1~n
        for(int i=0; i<n; i++){
            cn[i] = T.Combination(n-1,i);
        }
        arr = new int[n]; // 1~n 들어있는 배열
        for (int i=0; i<n; i++) arr[i] = i+1;
        T.DFS(0);
    }
}
```

**강의 풀이방법**
- 내 풀이와의 차이점 :
- 나는 arr 배열을 만들어서 1~n까지의 수를 저장했지만, 어차피 1부터 n까지의 값이므로 그냥 for문으로 대체한다.
- 나는 레벨이 n이 될 때, 한 번에 sum을 구했지만, 재귀호출로 sum을 넘겨줌으로써 수열에 넣는 수 하나하나마다 계산하였다.
    - 이렇게 했을 때의 장점은, sum을 그때그때 구함으로써 sum이 f를 넘는 함수는 그 뒤의 과정을 거칠 필요가 없으므로 그냥 종료해버릴 수 있다. 즉, 함수 종료의 기준을 세울 수 있게 된다. -> 시간복잡도 줄어든다.
    
**얻어갈 것**
- 내가 결국 만들어야 되는 수열은 문제에서 조건으로 나오는 sum을 만들 수 있는 수열이다. 그러므로, sum을 재귀호출의 인자로 넘겨준다면 레벨이 n이 되기 전에도 문제 조건을 만족하지 못하는 함수인지 판별할 수 있게 됨으로써 시간복잡도를 줄일 수 있다. 