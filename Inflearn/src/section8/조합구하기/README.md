# 조합 구하기

## 문제
```
[설명]
1부터 N까지 번호가 적힌 구슬이 있습니다. 이 중 M개를 뽑는 방법의 수를 출력하는 프로그
램을 작성하세요.

[입력]
첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다.

[출력]
첫 번째 줄에 결과를 출력합니다.
출력순서는 사전순으로 오름차순으로 출력합니다.
```
```
입력예제 1
4 2

출력예제 1
1 2
1 3
1 4
2 3
2 4
3 4
```

**첫 번째 풀이방법**
1. 레벨마다 어떤 원소를 조합에 넣을지 결정하기 위해 for 문을 통해 선택한다.
    - 조합에 한 숫자가 중복되어 들어갈 수는 없기 때문에 ch 배열을 통해 중복 여부를 체크한다.
2. 결정한 숫자가 또 선택되어 중복되지 않도록 ch 배열에 체크를 한다.
3. 다음으로 들어올 숫자를 결정하기 위해 for 문에서 재귀호출을 한다.
4. 위 과정을 레벨(L) == m이 될 때까지 반복하고, 레벨이 m이 되면 조합에 넣을 숫자를 모두 선택한 것이므로 출력한다.
- 이 과정까지는 순열을 구하는 방법과 완전히 똑같다. 하지만, 순열과 조합은 차이점이 있다.
- 순열에서는 들어가는 원소가 같더라도 순서가 다르다면 허용된다. 하지만, 조합은 순서가 다르더라도 완전히 같은 원소가 들어가면 안 된다. 즉, 순서를 다르게 했을 때 같은 조합이 된다면 이는 조합이 될 수 없다.
    - ex) 순열에서는 (2 1) (1 2) 와 같이 순서가 다른 경우가 허용된다.
    - 하지만, 조합에서는 (2 1) (1 2)의 경우 (1 2)의 순서를 다르게 했을 경우(2 1)이 되고, 이 경우에는 조합이 될 수 없다.
- 이러한 케이스를 없애기 위해 위 풀이 과정의 4번, 출력 과정에서 조합의 첫 번째 인덱스를 또 다른 ch2 배열을 만들어서 뽑히지 않도록 한다.

Code
```java
public class Main {
    static int n,m;
    static int[] ch1, ch2, p;

    public void DFS(int L){
        if(L==m){
            for(int x : p) System.out.print(x + " ");
            System.out.println();
            ch2[p[0]] = 1;
        }
        else{
            for(int i=1; i<=n; i++){
                if(ch1[i] == 0 && ch2[i] == 0){
                    ch1[i] = 1;
                    p[L] = i;
                    DFS(L+1);
                    ch1[i] = 0;
                }
            }
        }
    }
    public static void main(String[] args) {
        Main T = new Main();
        Scanner sc= new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        p = new int[m];
        ch1 = new int[n+1];
        ch2 = new int[n+1];
        T.DFS(0);
    }
}
```

**강의 풀이방법**
- 이미 원소가 조합에 들어갔는지 확인하기 위한 체크 배열을 사용하지 않고, DFS 메소드의 인자로 start 변수를 받는다.
- start 변수는 해당 레벨에 들어갈 수 있는 값의 범위를 제한하는 역할을 한다.
    - 1부터 시작하는 start 변수로 인해 첫 원소는 for문에서 1로 뽑히게 된다.
    - 그 후에 파라미터를 i+1로 재귀호출하게 된다. 즉, 두 번째 호출된 DFS 함수의 for문은 2부터 돌게 된다.
    - 즉, 이미 뽑은 숫자보다 1 높은 숫자부터 뽑을 수 있도록 제한하는 것이다.

나는 이미 숫자가 들어갔는지 확인하기 위한 ch1 배열과, 해당 원소로 만들 수 있는 조합을 다 만들었는지 여부를 체크하기 위한 ch2 배열을 사용하였지만, 위와 같은 방법을 사용하면 더욱 간단하게 문제를 해결할 수 있다.

**얻어갈 것**
- 조합 고르는 법은 방법을 외워도 될 정도로 숙지가 필요하다.