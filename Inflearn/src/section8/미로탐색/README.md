# 미로탐색(DFS)

## 문제
```
[설명]
7*7 격자판 미로를 탈출하는 경로의 가지수를 출력하는 프로그램을 작성하세요.

출발점은 격자의 (1, 1) 좌표이고, 탈출 도착점은 (7, 7)좌표이다. 격자판의 1은 벽이고, 0은 통로이다.

격자판의 움직임은 상하좌우로만 움직인다. 미로가 다음과 같다면
```
![image](https://cote.inflearn.com/public/upload/72540f8a90.jpg)
```
위의 지도에서 출발점에서 도착점까지 갈 수 있는 방법의 수는 8가지이다.


[입력]
7*7 격자판의 정보가 주어집니다.


[출력]
첫 번째 줄에 경로의 가지수를 출력한다.
```
```
예시 입력 1 
0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 0 0 1 0 0 0
1 1 0 1 0 1 1
1 1 0 0 0 0 1
1 1 0 1 1 0 0
1 0 0 0 0 0 0

예시 출력 1
8
```

**첫 번째 풀이방법**
- 방향에 따른 재귀호출을 하기 위해 mx와 my 배열을 인덱스에 맞춰 3시 방향, 6시 방향, 9시 방향, 12시 방향으로 이동할 수 있도록 저장한다. 
- for 문에서 한 가지 방향을 골라 (1)x,y 좌표가 각각 1과 7 사이에 있으며, (2)이미 지나온 곳이 아니라면 이동(재귀호출)을 한다.
    - 이때, 이미 지나온 길은 다시 가지 않도록 하기 위해 ch배열을 생성해 체크를 해준다.
    - 함수가 종료되면 체크를 풀어준다.
    - 위 과정을 반복하며 이동한다.
- 만약 이동해온 점(x,y)이 벽이라면 유효하지 않은 이동이므로 종료한다.
- 이동한 점의 좌표가 (7,7)이라면 목적지에 도착한 것이므로 경우의 수를 하나 증가시킨다.

Code
```java
public class Main {
    static int answer=0;
    static int[] my = new int[]{0,1,0,-1};
    static int[] mx = new int[]{1,0,-1,0};
    // 3시, 6시, 9시, 12시 방향 순서

    static int[][] arr = new int[8][8];
    static int[][] ch = new int[8][8];


    public void DFS(int y, int x){
        if(arr[y][x] == 1) return; // 벽으로 갔을 때
        if(x == 7 && y == 7) { // 목적지에 도착했을 때
            answer++; // 경우의 수 증가
        }
        else {
            for(int i=0; i<4; i++) {
                int nx = x + mx[i], ny = y + my[i];
                if(nx >= 1 && nx <= 7 && ny >= 1 && ny <= 7) { // 가려고 하는 곳의 x,y 좌표가 1~7 사이어야 됨
                    if (ch[ny][nx] == 0) { // 이미 갔던 곳이 아니라면 -> 갔던 곳은 다시 못 가도록
                        ch[ny][nx] = 1; // 갈 곳이니까 체크해놓고
                        DFS(ny, nx); // 간다
                        ch[ny][nx] = 0; // 함수 끝났으면 체크 해제
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Main T = new Main();
        Scanner sc = new Scanner(System.in);
        for(int i=0; i<8; i++){
            arr[0][i] = 1;
            arr[i][0] = 1;
        }
        for(int i=1; i<=7; i++){
            for(int j=1; j<=7; j++) arr[i][j] = sc.nextInt();
        }
        ch[1][1] = 1;
        T.DFS(1,1);
        System.out.println(answer);
    }
}
```

**강의 풀이방법**
- 나는 지나온 점을 또 다시 지나지 않기 위해 ch 배열을 사용했다.
- 강의에서는 지나온 점을 ch에 체크하지 않고, 해당 좌표값을 벽(1)로 만들고 지나간다.
- 나는 도착한 점이 벽인지(arr[y][x] == 1) 검사하는 코드와, 다음번에 가려고 하는 좌표가 이미 지나온 좌표인지(ch[ny][nx] == 0) 검사하는 코드를 분리해서 작성했지만, ch 배열을 사용하지 않고 지나온 길을 벽으로 만듦으로써 이를 합칠 수 있다.

**얻어갈 것**
- ch 배열을 사용하는 이유는 어차피 다시 지나가게 못 하기 위함이다! -> 벽 또한 못 지나가게 하는 역할을 할 수 있으니 이를 이용하는 것을 생각